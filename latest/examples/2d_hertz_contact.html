<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>2D Hertz contact problem · JuliaFEM</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-83590644-1', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>JuliaFEM</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Examples</span><ul><li class="current"><a class="toctext" href="2d_hertz_contact.html">2D Hertz contact problem</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#Results-1">Results</a></li></ul></li><li><a class="toctext" href="3d_frame.html">Natural frequency analysis of 3d frame structure</a></li><li><a class="toctext" href="generate_stiffness_matrices.html">Generating local matrices for problems</a></li></ul></li><li><span class="toctext">Developer&#39;s guide</span><ul><li><a class="toctext" href="../packages/FEMBase/mesh.html">Mesh</a></li><li><a class="toctext" href="../packages/FEMBase/fields.html">Fields</a></li><li><a class="toctext" href="../packages/FEMBase/basis.html">Basis functions</a></li><li><a class="toctext" href="../packages/FEMBase/integration.html">Integration</a></li><li><a class="toctext" href="../packages/FEMBase/elements.html">Elements</a></li><li><a class="toctext" href="../packages/FEMBase/problems.html">Problems</a></li><li><a class="toctext" href="../packages/FEMBase/solvers.html">Analyses and solvers</a></li><li><a class="toctext" href="../packages/FEMBase/postprocessing.html">Postprocessing</a></li><li><a class="toctext" href="../packages/FEMBase/results.html">Results</a></li><li><a class="toctext" href="../packages/FEMBase/materials.html">Materials</a></li></ul></li><li><span class="toctext">Description of packages</span><ul><li><a class="toctext" href="../packages/FEMQuad/index.html">FEMQuad.jl documentation</a></li><li><a class="toctext" href="../packages/AsterReader/index.html">AsterReader.jl documentation</a></li><li><a class="toctext" href="../packages/AbaqusReader/index.html">AbaqusReader.jl documentation</a></li><li><a class="toctext" href="../packages/HeatTransfer/index.html">HeatTransfer.jl</a></li><li><a class="toctext" href="../packages/FEMBeam/index.html">Introduction</a></li><li><a class="toctext" href="../packages/MortarContact2D/index.html">MortarContact2D.jl</a></li><li><a class="toctext" href="../packages/MortarContact2DAD/index.html">MortarContact2DAD.jl</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Examples</li><li><a href="2d_hertz_contact.html">2D Hertz contact problem</a></li></ul><a class="edit-page" href="https://github.com/JuliaFEM/JuliaFEM.jl/blob/master/examples/2d_hertz_contact.jl"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>2D Hertz contact problem</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="D-Hertz-contact-problem-1" href="#D-Hertz-contact-problem-1">2D Hertz contact problem</a></h1><p><img src="2d_hertz_contact/model.png" alt/></p><p>In the example, a cylinder is pressed agains block with a force of 35 kN. A similar example can be found from NAFEMS report FENET D3613 (advanced finite element contact benchmarks).</p><p>Solution for maximum pressure <span>$p_0$</span> and contact radius <span>$a$</span> is</p><div>\[  p_{0} = \sqrt{\frac{FE}{2\pi R}}, \\
  a     = \sqrt{\frac{8FR}{\pi E}},\]</div><p>where</p><div>\[  E = \frac{2E_{1}E_{2}}{E_{2}\left(1-\nu_{1}^{2}\right)+E_{1}\left(1-\nu_{2}^{2}\right)}.\]</div><p>Substituting values, one gets accurate solution to be <span>$p_0 = 3585 \;\mathrm{MPa}$</span> and <span>$a = 6.21 \;\mathrm{mm}$</span>.</p><div><pre><code class="language-julia">using JuliaFEM
using JuliaFEM.Preprocess
using JuliaFEM.Postprocess
using Logging
Logging.configure(level=INFO)
add_elements! = JuliaFEM.add_elements!</code></pre><pre><code class="language-none">add_elements! (generic function with 5 methods)</code></pre></div><p>Simulation starts by reading the mesh. Model is constructed and meshed using SALOME, thus mesh format is .med. Mesh type is quite simple structure, containing things like <code>mesh.nodes</code>, <code>mesh.elements</code> and so on. Keep on mind, that Mesh contains only standard Julia types and we think it as a structure helping us to construct elements needed in simulation. In principle, we don&#39;t need to use <code>Mesh</code> in simulation anyway if we figure some other way to define the geometry for elements.</p><div><pre><code class="language-julia">datadir = Pkg.dir(&quot;JuliaFEM&quot;, &quot;examples&quot;, &quot;2d_hertz_contact&quot;)
meshfile = joinpath(datadir, &quot;hertz_2d_full.med&quot;)
mesh = aster_read_mesh(meshfile)
for (elset_name, element_ids) in mesh.element_sets
    nel = length(element_ids)
    println(&quot;Element set $elset_name contains $nel elements.&quot;)
end
for (nset_name, node_ids) in mesh.node_sets
    nno = length(node_ids)
    println(&quot;Node set $nset_name contains $nno nodes.&quot;)
end
nnodes = length(mesh.nodes)
println(&quot;Total number of nodes in mesh: $nnodes&quot;)
nelements = length(mesh.elements)
println(&quot;Total number of elements in mesh: $nelements&quot;)</code></pre><pre><code class="language-none">Element set FIXED contains 10 elements.
Element set OTHER contains 63 elements.
Element set BLOCK_TO_CYLINDER contains 6 elements.
Element set CYLINDER_TO_BLOCK contains 6 elements.
Element set SYM23 contains 11 elements.
Element set CYLINDER contains 133 elements.
Element set BLOCK contains 328 elements.
Node set CYLINDER_LOAD contains 1 nodes.
Node set OTHER contains 270 nodes.
Node set CYLINDER_CONTACT_POINT contains 1 nodes.
Node set CYLINDER_RIGHT contains 1 nodes.
Node set BLOCK_CONTACT_POINT contains 1 nodes.
Node set CYLINDER_LEFT contains 1 nodes.
Total number of nodes in mesh: 275
Total number of elements in mesh: 557</code></pre></div><p>Next, define two bodies. Technically, we could have only one problem and add elements from both bodies to the same problem, but defining two different problems is recommended for clarity. Plain strain assumption is used. To make clear what is happening here: we first create a set of elements (elements are in vector called <code>upper_elements</code>), then we define new problem which type is <code>Elasticity</code>, give it some meaningful name (this time <code>cylinder</code>), and last value 2 means that problems does have two degrees of freedom per node.</p><div><pre><code class="language-julia">upper_elements = create_elements(mesh, &quot;CYLINDER&quot;)
update!(upper_elements, &quot;youngs modulus&quot;, 70.0e3)
update!(upper_elements, &quot;poissons ratio&quot;, 0.3)
upper = Problem(Elasticity, &quot;cylinder&quot;, 2)
upper.properties.formulation = :plane_strain
add_elements!(upper, upper_elements)

lower_elements = create_elements(mesh, &quot;BLOCK&quot;)
update!(lower_elements, &quot;youngs modulus&quot;, 210.0e3)
update!(lower_elements, &quot;poissons ratio&quot;, 0.3)
lower = Problem(Elasticity, &quot;block&quot;, 2)
lower.properties.formulation = :plane_strain
add_elements!(lower, lower_elements)</code></pre></div><p>Next we define some boundary conditions: creating &quot;boundary&quot; problems goes in the same way than defining &quot;field&quot; problems, the only difference is that we add extra argument giving what field are we tring to fix. This time, we have 2 dofs / node and we fix displacement in direction 2.</p><div><pre><code class="language-julia">bc_fixed_elements = create_elements(mesh, &quot;FIXED&quot;)
update!(bc_fixed_elements, &quot;displacement 2&quot;, 0.0)
bc_fixed = Problem(Dirichlet, &quot;fixed&quot;, 2, &quot;displacement&quot;)
add_elements!(bc_fixed, bc_fixed_elements)</code></pre></div><p>Defining symmetry boundary condition goes with the same idea</p><div><pre><code class="language-julia">bc_sym_23_elements = create_elements(mesh, &quot;SYM23&quot;)
update!(bc_sym_23_elements, &quot;displacement 1&quot;, 0.0)
bc_sym_23 = Problem(Dirichlet, &quot;symmetry line 23&quot;, 2, &quot;displacement&quot;)
add_elements!(bc_sym_23, bc_sym_23_elements)</code></pre></div><p>Next we define point load. To define that, we first need to find some node near the top of cylinder, using function <code>find_nearest_node</code>. Then we create a new problem, again of type Elasticity. Like told already, we don&#39;t need to use <code>Mesh</code> if we have some other procedure to define the geometry of the element (and it&#39;s connectivity, of course). So we can directly create an element of type <code>Poi1</code>, meaning 1-node point element, update it&#39;s geometry and apply 35.0e3 kN load in negative y-direction:</p><div><pre><code class="language-julia">nid = find_nearest_node(mesh, [0.0, 100.0])
load = Problem(Elasticity, &quot;point load&quot;, 2)
load.properties.formulation = :plane_strain
load.elements = [Element(Poi1, [nid])]
update!(load.elements, &quot;geometry&quot;, mesh.nodes)
update!(load.elements, &quot;displacement traction force 2&quot;, -35.0e3)</code></pre></div><p>Next, we define another boudary problem, this time the type of problem is Contact2D, which is a mortar contact formulation for two dimensions. Elements are added using <code>add_slave_elements!</code> and <code>add_master_elements!</code>. Problems, in general, can have some properties defined, like the formulation in <code>Elasticity</code> (we also have <code>:plane_stress</code>). For contact, we need to swap normal direction for meshes created by SALOME because in Code Aster, element orientation is defined opposite to what is used in ABAQUS, and in JuliaFEM in general we follow the same conventions what are used in ABAQUS.</p><div><pre><code class="language-julia">contact = Problem(Contact2D, &quot;contact&quot;, 2, &quot;displacement&quot;)
contact.properties.rotate_normals = true
contact_slave_elements = create_elements(mesh, &quot;BLOCK_TO_CYLINDER&quot;)
contact_master_elements = create_elements(mesh, &quot;CYLINDER_TO_BLOCK&quot;)
add_master_elements!(contact, contact_master_elements)
add_slave_elements!(contact, contact_slave_elements)</code></pre></div><p>After all problems are defined, we define some <code>Analysis</code>, which can be e.g. static analysis, dynamic analysis, modal analysis, linear perturbation analysis and so on. Here, the analysis type is <code>Nonlinear</code>, which is nonlinear quasistatic analysis. In the same manner as we do <code>add_elements!</code> to add elements to <code>Problem</code>, we use <code>add_problems!</code> to add problems to analysis. Because we are not restricted to some particular input and output formats, we &quot;connect&quot; a <code>ResultsWriter</code> to our analysis, this time we want to visualize results using ParaView, thus we write our results to Xdmf format, which uses well defined standards XML and HDF to store model data.</p><div><pre><code class="language-julia">step = Analysis(Nonlinear)
add_problems!(step, [upper, lower, bc_fixed, bc_sym_23, load, contact])
xdmf = Xdmf(&quot;2d_hertz_results&quot;; overwrite=true)
# todo for 2d
# for body in (upper, lower)
#     push!(body.postprocess_fields, &quot;stress&quot;)
# end
add_results_writer!(step, xdmf)</code></pre><pre><code class="language-none">1-element Array{FEMBase.AbstractResultsWriter,1}:
 JuliaFEM.Xdmf(&quot;2d_hertz_results&quot;, &lt;Xdmf xmlns:xi=&quot;http://www.w3.org/2001/XInclude&quot; Version=&quot;3.0&quot;/&gt;, HDF5 data file: 2d_hertz_results.h5, 1, &quot;HDF&quot;)</code></pre></div><p>In last part, we run the analysis.</p><div><pre><code class="language-julia">step()</code></pre><pre><code class="language-none">true</code></pre></div><h1><a class="nav-anchor" id="Results-1" href="#Results-1">Results</a></h1><p>Results are stored in <code>2d_hertz_results.xmf</code> and <code>2d_hertz_results.h5</code> for visual inspection. We can also postprocess results programmatically because we are inside a real scripting / programming environment all the time.  For example, we can integrate the resultant force in normal and tangential direction in contact surface to validate our result.</p><div><pre><code class="language-julia">Rn = 0.0
Rt = 0.0
time = 0.0
for sel in contact_slave_elements
    for ip in get_integration_points(sel)
        w = ip.weight*sel(ip, time, Val{:detJ})
        n = sel(&quot;normal&quot;, ip, time)
        t = sel(&quot;tangent&quot;, ip, time)
        la = sel(&quot;lambda&quot;, ip, time)
        Rn += w*dot(n, la)
        Rt += w*dot(t, la)
    end
end

println(&quot;2d hertz contact resultant forces: Rn = $Rn, Rt = $Rt&quot;)

using Base.Test
@test isapprox(Rn, 35.0e3)
@test isapprox(Rt, 0.0)</code></pre><pre><code class="language-none">2d hertz contact resultant forces: Rn = 35000.000000000015, Rt = 0.0
Test Passed</code></pre></div><p>Visualization of the results can be done using ParaView: <img src="2d_hertz_contact/results_displacement.png" alt/></p><p>For optimization loops, we want to programmatically find, for example, maximum contact pressure. We can, for example, get all the values in nodes:</p><div><pre><code class="language-julia">lambda = contact(&quot;lambda&quot;, time)
normal = contact(&quot;normal&quot;, time)
p0 = 0.0
p0_acc = 3585.0
for (nid, n) in normal
    lan = dot(n, lambda[nid])
    println(&quot;$nid =&gt; $lan&quot;)
    p0 = max(p0, lan)
end
p0 = round(p0, 2)
rtol = round(norm(p0-p0_acc)/max(p0,p0_acc)*100, 2)
println(&quot;Maximum contact pressure p0 = $p0, p0_acc = $p0_acc, rtol = $rtol %&quot;)</code></pre><pre><code class="language-none">133 =&gt; 0.0
135 =&gt; 4056.0177563032744
145 =&gt; 0.0
144 =&gt; 583.5173932223679
137 =&gt; 0.0
122 =&gt; 0.0
134 =&gt; 821.4109821941494
Maximum contact pressure p0 = 4056.02, p0_acc = 3585.0, rtol = 11.61 %</code></pre></div><p>To get rough approximation where does the contact open, we can find the element from slave contact surface, where contact pressure is zero in the other node and something nonzero in the other node.</p><div><pre><code class="language-julia">a_rad = 0.0
for element in contact_slave_elements
    la1, la2 = element(&quot;lambda&quot;, time)
    p1, p2 = norm(la1), norm(la2)
    a, b = isapprox(p1, 0.0), isapprox(p2, 0.0)
    if (a &amp;&amp; !b) || (b &amp;&amp; !a)
        X1, X2 = element(&quot;geometry&quot;, time)
        println(&quot;Contact opening element geometry: X1 = $X1, X2 = $X2&quot;)
        println(&quot;Contact opening element lambda: la1 = $la1, la2 = $la2&quot;)
        x11, y11 = X1
        x12, y12 = X2
        a_rad = 1/2*abs(x11+x12)
        break
    end
end
println(&quot;Contact radius: $a_rad&quot;)</code></pre><pre><code class="language-none">Contact opening element geometry: X1 = [13.6585, 0.0], X2 = [6.56633, 0.0]
Contact opening element lambda: la1 = [0.0, 0.0], la2 = [0.0, 583.517]
Contact radius: 10.11240722215463</code></pre></div><p>This example briefly described some of the core features of JuliaFEM.</p><div><pre><code class="language-julia">close(xdmf.hdf) # src</code></pre></div><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p><footer><hr/><a class="previous" href="../index.html"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="3d_frame.html"><span class="direction">Next</span><span class="title">Natural frequency analysis of 3d frame structure</span></a></footer></article></body></html>
