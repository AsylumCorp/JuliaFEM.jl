<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Natural frequency analysis of 3d frame structure · JuliaFEM</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-83590644-1', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>JuliaFEM</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="2d_hertz_contact.html">2D Hertz contact problem</a></li><li class="current"><a class="toctext" href="3d_frame.html">Natural frequency analysis of 3d frame structure</a><ul class="internal"></ul></li><li><a class="toctext" href="generate_stiffness_matrices.html">Generating local matrices for problems</a></li></ul></li><li><span class="toctext">Developer&#39;s guide</span><ul><li><a class="toctext" href="../packages/FEMBase/mesh.html">Mesh</a></li><li><a class="toctext" href="../packages/FEMBase/fields.html">Fields</a></li><li><a class="toctext" href="../packages/FEMBase/basis.html">Basis functions</a></li><li><a class="toctext" href="../packages/FEMBase/integration.html">Integration</a></li><li><a class="toctext" href="../packages/FEMBase/elements.html">Elements</a></li><li><a class="toctext" href="../packages/FEMBase/problems.html">Problems</a></li><li><a class="toctext" href="../packages/FEMBase/solvers.html">Analyses and solvers</a></li><li><a class="toctext" href="../packages/FEMBase/postprocessing.html">Postprocessing</a></li><li><a class="toctext" href="../packages/FEMBase/results.html">Results</a></li><li><a class="toctext" href="../packages/FEMBase/materials.html">Materials</a></li></ul></li><li><span class="toctext">Description of packages</span><ul><li><a class="toctext" href="../packages/FEMQuad/index.html">FEMQuad.jl documentation</a></li><li><a class="toctext" href="../packages/AsterReader/index.html">AsterReader.jl documentation</a></li><li><a class="toctext" href="../packages/AbaqusReader/index.html">AbaqusReader.jl documentation</a></li><li><a class="toctext" href="../packages/HeatTransfer/index.html">HeatTransfer.jl</a></li><li><a class="toctext" href="../packages/FEMBeam/index.html">Introduction</a></li><li><a class="toctext" href="../packages/MortarContact2D/index.html">MortarContact2D.jl</a></li><li><a class="toctext" href="../packages/MortarContact2DAD/index.html">MortarContact2DAD.jl</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Examples</li><li><a href="3d_frame.html">Natural frequency analysis of 3d frame structure</a></li></ul><a class="edit-page" href="https://github.com/JuliaFEM/JuliaFEM.jl/blob/master/examples/3d_frame.jl"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Natural frequency analysis of 3d frame structure</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Natural-frequency-analysis-of-3d-frame-structure-1" href="#Natural-frequency-analysis-of-3d-frame-structure-1">Natural frequency analysis of 3d frame structure</a></h1><p>For general information about Euler-Bernoulli beam theory, see <a href="https://en.wikipedia.org/wiki/Euler%E2%80%93Bernoulli_beam_theory">this</a> wikipedia page.</p><p>The model is a 3d frame, shown in picture.</p><p><img src="3d_frame/model.png" alt/></p><div><pre><code class="language-julia">using JuliaFEM
using JuliaFEM.Preprocess
using FEMBase.Test
using Logging
Logging.configure(level=INFO)
add_elements! = JuliaFEM.add_elements!</code></pre><pre><code class="language-none">add_elements! (generic function with 5 methods)</code></pre></div><p>Reading mesh</p><div><pre><code class="language-julia">datadir = Pkg.dir(&quot;JuliaFEM&quot;, &quot;examples&quot;, &quot;3d_frame&quot;)
mesh = aster_read_mesh(joinpath(datadir, &quot;model.med&quot;))
println(&quot;Number of nodes in a model: &quot;, length(mesh.nodes))</code></pre><pre><code class="language-none">Number of nodes in a model: 360</code></pre></div><p>Create beam elements. For 3d model, we need to define at least <a href="https://en.wikipedia.org/wiki/Young%27s_modulus">Young&#39;s modulus</a>, <a href="https://en.wikipedia.org/wiki/Shear_modulus">shear modulus</a>, <a href="https://en.wikipedia.org/wiki/Density">density</a> cross-section area, moment of inertia in local coordinate system and polar moment of inertia.</p><div><pre><code class="language-julia">beam_elements = create_elements(mesh, &quot;FRAME&quot;)
info(&quot;Number of elements: &quot;, length(beam_elements))
update!(beam_elements, &quot;youngs modulus&quot;, 210.0e6)
update!(beam_elements, &quot;shear modulus&quot;, 84.0e6)
update!(beam_elements, &quot;density&quot;, 7850.0e-3)
update!(beam_elements, &quot;cross-section area&quot;, 20.0e-2)
update!(beam_elements, &quot;torsional moment of inertia 1&quot;, 10.0e-5)
update!(beam_elements, &quot;torsional moment of inertia 2&quot;, 10.0e-5)
update!(beam_elements, &quot;polar moment of inertia&quot;, 30.0e-5)</code></pre></div><p>The direction of beam is defined in same way than in ABAQUS. That is, we have a tangent direction and one normal direction. The third direction is then cross product of tangent and normal. Because the second area moment is same in both directions, we can choose normal direction freely.</p><div><pre><code class="language-julia">for element in beam_elements
    X1, X2 = element(&quot;geometry&quot;, 0.0)
    t = (X2-X1)/norm(X2-X1)
    I = eye(3)
    k = indmax([norm(cross(t, I[:,k])) for k in 1:3])
    n = cross(t, I[:,k])/norm(cross(t, I[:,k]))
    update!(element, &quot;normal&quot;, n)
end</code></pre></div><p>Create boundary conditions: fix all degrees of freedom for nodes in a set FIXED. Here we first create elements of type <code>Poi1</code> for each node j in set FIXED, update geometry field and then create new fields <code>fixed displacmeent 1</code>, <code>fixed displacement 2</code>, and so on, where the displacement / rotation is prescribed.</p><div><pre><code class="language-julia">bc_elements = [Element(Poi1, [j]) for j in mesh.node_sets[:FIXED]]
update!(bc_elements, &quot;geometry&quot;, mesh.nodes)
for i=1:3
    update!(bc_elements, &quot;fixed displacement $i&quot;, 0.0)
    update!(bc_elements, &quot;fixed rotation $i&quot;, 0.0)
end</code></pre></div><p>Create a problem, containing beam elements and boundary conditions:</p><div><pre><code class="language-julia">frame = Problem(Beam, &quot;3d frame&quot;, 6)
add_elements!(frame, beam_elements)
add_elements!(frame, bc_elements)</code></pre></div><p>Perform modal analysis</p><div><pre><code class="language-julia">step = Analysis(Modal)
xdmf = Xdmf(joinpath(datadir, &quot;3d_frame_results&quot;); overwrite=true)
add_results_writer!(step, xdmf)
add_problems!(step, [frame])
run!(step)
close(xdmf.hdf)</code></pre></div><p>Each <code>Analysis</code> can have properties, e.g. time, maximum number of iterations, convergence tolerance and so on. Eigenvalues of calculation are stored as a properties of analysis:</p><div><pre><code class="language-julia">freqs = sqrt.(step.properties.eigvals) / (2*pi)
println(&quot;Natural frequencies [Hz]: $(round.(freqs, 2))&quot;)</code></pre><pre><code class="language-none">Natural frequencies [Hz]: [2.06, 2.06, 2.84, 5.65, 11.34, 11.35, 12.36, 12.64, 12.64, 14.76]</code></pre></div><p><a href="https://www.youtube.com/watch?v=GzktCqeASmo"><img src="3d_frame/natfreq.png" alt="mode5"/></a></p><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p><footer><hr/><a class="previous" href="2d_hertz_contact.html"><span class="direction">Previous</span><span class="title">2D Hertz contact problem</span></a><a class="next" href="generate_stiffness_matrices.html"><span class="direction">Next</span><span class="title">Generating local matrices for problems</span></a></footer></article></body></html>
